@startuml Metastore
namespace Controller {
    class MetastoreController {
        +getItem($identifier)
        +getItems(): **MetastoreItemInterface[]**
        +getCatalog()
        +getSchema($schemaId)
        +getSchemas()
        +postItem()
        +patchItem()
        +putItem()
        +deleteItem($schemaId)
        +publishItem($schemaId)
    }
}

class SchemaRetriever {
    ""dkan.metastore.schema_retriever""
    +get($schemaId)
    +getAll()
    +getAllIds()
}

interface MetadataRetrieverInterface {
    +getAllIds(): **string[]**
    +load(string $schemaId, string $identifier[...]): **MetastoreItemInterface**
    +loadMultiple(string $schemaId[...]): **MetastoreItemInterface[]**
    +loadContains($string): **MetastoreItemNode**[]
    +loadByHash(string $hash): **MetastoreItemInterface**
    +catalog()
}

class MetadataWriter {
    ""dkan.metastore.metadata_writer""
    +create($data)
    +merge(string $identifier, $data)
    +replace(string $identifier, $data)
    +delete(string $identifier)
    +publish(string $identifier)
}


interface MetastoreItemInterface {
    #$referenced **RootedJsonData**
    #$dereferenced **RootedJsonData**
    +__to_string()
    +identifier()
    +schemaId()
    +modified()
    +getReferenced(): **RootedJsonData**
    +getDereferenced(): **RootedJsonData**
    +setMetadata($data): **bool**
    +replace($json)
    +merge($json)
}
note left of MetastoreItemInterface::__to_string
    wrapper for
    <code>
    $this->getDereferenced()
        ->__to_string();
end note

interface MetastoreItemFactoryInterface {
    {static} +wrap(**Drupal\core\Entity** $entity): **MetastoreItemInterface**
}

note bottom
    Used in contexts where we have an entity object but don't know
    the schemaId. For instance, in an entity update or insert hook:

    <code>
    function hook_entity_update($entity) {
        $metastoreItem = \Drupal::service('dkan.metastore.item_factory')
        ->wrap($entity);
        $schemaId = $metastoreItem->schemaId();
    }
    </code>
end note

namespace ItemNode {

    class ItemNode implements .MetastoreItemInterface {
        #$node
        ---
        {inherited}
    }

    class ItemNodeRetriever implements .MetadataRetrieverInterface {
        ""dkan.metastore.metadata_retriever""
    }

    class ItemNodeFactory implements .MetastoreItemFactoryInterface {
        ""dkan.metastore.item_factory""
        {static} +wrap(**Drupal\\node\Node** $node): **ItemNode**
    }

} 

Controller.MetastoreController --> SchemaRetriever

note as RetrieverNote
    MetadataRetriever methods pass ""MetastoreItemInterface""
    objects, which can be easily cast to strings, back to the controller. 
end note
ItemNode.ItemNodeRetriever *-- RetrieverNote
RetrieverNote --> Controller.MetastoreController

note as RetrieverServiceNote
    Controller get methods call 
    ""dkan.metastore.metadata_retriever""
end note
Controller.MetastoreController *-- RetrieverServiceNote
RetrieverServiceNote --> ItemNode.ItemNodeRetriever

note as WriterServiceNote
    Controller writer (patch, put etc) methods 
    call ""dkan.metastore.metadata_retriever""
end note
Controller.MetastoreController *-- WriterServiceNote
WriterServiceNote --> MetadataWriter


note as WriterNote
    MetadataWriter post/patch/put methods load single
    MetastoreItem objects and call //their// methods directly. 
    For a ""replace()"", this could look like:

    <code>
    /* @var string $identifier */
    /* @var RootedJsonData $newMetadata */
    $dataset = \Drupal::service('dkan.metastore.storage')
      ->getInstance('dataset')
      ->load($identifier);
    return $dataset->setMetadata($newMetadata);
    </code>
end note
MetadataWriter *-- WriterNote
WriterNote --> MetastoreItemInterface

' WriterNote -[hidden]> RetrieverStorageNote
' RetrieverNote -[hidden]> Controller
@enduml